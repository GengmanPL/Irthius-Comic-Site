//This is the main script that controls the pages.--> const characterWait = 35; // time between writing single characters. (milliseconds) const lineWait = 600; // time between lines that don't wait for user input. (milliseconds) const continueBar = document.getElementById("continue-bar"); continueBar.style.display = 'none'; let autoScroll = true; // true if user hasnâ€™t scrolled away let skipLoading = false let msgIndex = 0; // Simple time delay function function wait(ms) { return new Promise((resolve) => setTimeout(resolve, ms)); } async function textHandler() { while (msgIndex < messages.length && skipLoading == false) { const output = document.getElementById("output_" + msgIndex); const text = messages[msgIndex]; const isDialogue = dialogueLines.includes(msgIndex); const isLastLine = msgIndex === messages.length - 1; const textSpan = document.createElement("span"); output.appendChild(textSpan); // Only scroll if user is at bottom if (autoScroll) { window.scrollTo(0, document.body.scrollHeight); } // Type line text into the textSpan await typeText(textSpan, text, characterWait); // Create underscore only for dialogue lines let cursor = null; if (isDialogue && !isLastLine) { cursor = document.createElement("span"); cursor.classList.add("cursor"); cursor.textContent = "_"; cursor.style.display = "none"; output.appendChild(cursor); } // Wait depending on line type if (isDialogue) { if (cursor) cursor.style.display = "block"; await waitForInput(); } else if (isLastLine) { console.log("Last line"); var positions = textSpan.getBoundingClientRect(); continueBar.top = positions.top continueBar.style.display = 'inline'; } else { await wait(lineWait); } // hide underscore before new line if (cursor) cursor.style.display = "none"; msgIndex++; } } function typeText(element, text, speed) { return new Promise((resolve) => { element.innerHTML = text; element.style.visibility = "hidden"; //give every text character a visibility toggle basically const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null, false); const textNodes = []; while (walker.nextNode()) textNodes.push(walker.currentNode); textNodes.forEach((node) => { const frag = document.createDocumentFragment(); for (let char of node.textContent) { const span = document.createElement("span"); span.textContent = char; span.style.visibility = "hidden"; frag.appendChild(span); } node.parentNode.replaceChild(frag, node); }); element.style.visibility = "visible"; // reveal characters one by one const spans = element.querySelectorAll("span"); let i = 0; function reveal() { if (i < spans.length) { spans[i].style.visibility = "visible"; const char = spans[i].textContent; // <-- get the actual character i++; // adjust delay based on punctuation let delay = speed; if (/[,\-;]/.test(char)) delay = speed * 6; else if (/[.?!]/.test(char)) delay = speed * 10; setTimeout(reveal, delay); } else { resolve(); } } reveal(); }); } // Wait for user input. function waitForInput() { return new Promise((resolve) => { function onKey(e) { if (e.code === "Space") { // Change input key here e.preventDefault(); document.removeEventListener("keydown", onKey); resolve(); } } document.addEventListener("keydown", onKey); }); } // Listen for manual scrolling document.addEventListener('scroll', () => { let scroll = this.scrollY; }); document.getElementById("skipLink").addEventListener("click", event => { event.preventDefault(); skipLoading = true; }); // Start writing the page. textHandler();